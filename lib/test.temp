// lib/screen1.dart
import 'package:flutter/material.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:smart_inhaler/graphscreen.dart';
import 'dart:async';
import 'test.dart'; // Import screen 2
import 'graphscreen.dart'; // Import graph screen


// --- Constants (Moved here as they are specific to this screen's UI) ---
const Color _motionSensorCardColor = Color(0xFFB2EBF2); // Light Teal
const Color _buzzerButtonColor = Color(0xFFFFAB91); // Warm Coral
const Color _textColor = Color(0xFF212121);
const double _cardCornerRadius = 12.0;
const double _cardElevation = 4.0;

// --- Dose Counter Widget ---
class DoseCounter extends StatefulWidget {
  final int doseCount;
  final int maxDoseCount;
  final VoidCallback onEdit;

  const DoseCounter({
    Key? key,
    required this.doseCount,
    required this.maxDoseCount,
    required this.onEdit,
  }) : super(key: key);

  @override
  _DoseCounterState createState() => _DoseCounterState();
}

class _DoseCounterState extends State<DoseCounter>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _animation = Tween<double>(begin: 1.0, end: 1.2).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(covariant DoseCounter oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.doseCount < oldWidget.doseCount) {
      _animationController.reset();
      _animationController.forward();
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  Color _getProgressColor(double progress) {
    if (progress > 0.6) {
      return Colors.cyan; // Plenty of doses left
    } else if (progress > 0.3) {
      return Colors.orange; // Getting low
    } else {
      return Colors.red; // Very low, needs replacement
    }
  }

  @override
  Widget build(BuildContext context) {
    double progress = widget.doseCount / widget.maxDoseCount;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          const Text(
            'Doses Remaining', // Added title here
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.w500,
              color: _textColor,
            ),
          ),
          const SizedBox(height: 12),
          GestureDetector(
            onTap: widget.onEdit,
            child: Stack(
              alignment: Alignment.center,
              children: [
                // Outer progress circle
                SizedBox(
                  width: 230,
                  height: 230,
                  child: CircularProgressIndicator(
                    value: progress,
                    strokeWidth: 25,
                    backgroundColor: Colors.grey.withOpacity(0.2),
                    valueColor: AlwaysStoppedAnimation<Color>(_getProgressColor(progress)), // Use valueColor
                  ),
                ),
                // Inner circle with radial gradient and white numbers
                ScaleTransition(
                  scale: _animation,
                  child: Container(
                    width: 205,
                    height: 205,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      gradient: RadialGradient(
                        colors: [
                          Colors.blue,
                          Color(0xFF00008B), // Dark Blue
                        ],
                        center: Alignment.center,
                        radius: 0.7,
                      ),
                    ),
                    child: Center(
                      child: Text(
                        '${widget.doseCount}',
                        style: const TextStyle(
                          fontSize: 60,
                          fontWeight: FontWeight.bold,
                          color: Colors.white, // White text color
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8), // Add some space below the counter
           Text(
            'Tap to edit', // Hint for editing
            style: TextStyle(color: Colors.grey[600]),
          ),
        ],
      ),
    );
  }
}

// --- Motion Sensor Data Widget (Numerical Values Only) ---
class MotionSensorNumericalData extends StatelessWidget {
  final double accelX;
  final double accelY;
  final double accelZ;
  final double gyroX;
  final double gyroY;
  final double gyroZ;
  final double temp;

  const MotionSensorNumericalData({
    Key? key,
    required this.accelX,
    required this.accelY,
    required this.accelZ,
    required this.gyroX,
    required this.gyroY,
    required this.gyroZ,
    required this.temp,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: _cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(_cardCornerRadius),
      ),
      color: _motionSensorCardColor,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Motion Sensor Data (Numerical)',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.w500,
                color: _textColor,
              ),
            ),
            const SizedBox(height: 12),
            _buildDataRow('Acceleration X:', accelX.toStringAsFixed(3)),
            _buildDataRow('Acceleration Y:', accelY.toStringAsFixed(3)),
            _buildDataRow('Acceleration Z:', accelZ.toStringAsFixed(3)),
            _buildDataRow('Gyroscope X:', gyroX.toStringAsFixed(3)),
            _buildDataRow('Gyroscope Y:', gyroY.toStringAsFixed(3)),
            _buildDataRow('Gyroscope Z:', gyroZ.toStringAsFixed(3)),
            const SizedBox(height: 12),
            _buildDataRow('Temperature:', '${temp.toStringAsFixed(1)}Â°C'),
          ],
        ),
      ),
    );
  }

  Widget _buildDataRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: _textColor,
            ),
          ),
          Text(
            value,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: _textColor,
            ),
          ),
        ],
      ),
    );
  }
}


// --- Buzzer Control Widget ---
class BuzzerControl extends StatefulWidget {
  final int buzzerControl;
  final VoidCallback onToggle;

  const BuzzerControl({
    Key? key,
    required this.buzzerControl,
    required this.onToggle,
  }) : super(key: key);

  @override
  _BuzzerControlState createState() => _BuzzerControlState();
}

class _BuzzerControlState extends State<BuzzerControl>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _scaleAnimation; // For button press effect

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500), // Slower pulse
    );
     _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );

    if (widget.buzzerControl != 0) {
      _animationController.repeat(reverse: true);
    }
  }

  @override
  void didUpdateWidget(covariant BuzzerControl oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.buzzerControl != oldWidget.buzzerControl) {
      if (widget.buzzerControl != 0) {
        if (!_animationController.isAnimating) {
           _animationController.repeat(reverse: true);
        }
      } else {
        _animationController.stop();
        _animationController.reset(); // Reset to normal state when off
      }
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void _handleTapDown(TapDownDetails details) {
     _animationController.forward(); // Start press animation
  }

   void _handleTapUp(TapUpDetails details) {
     _animationController.reverse(); // Reverse press animation
     widget.onToggle(); // Trigger the actual toggle
   }

   void _handleTapCancel() {
      _animationController.reverse(); // Reverse press animation if tap is cancelled
   }


  @override
  Widget build(BuildContext context) {
    bool isActive = widget.buzzerControl != 0;

    return GestureDetector( // Use GestureDetector for tap effects
       onTapDown: _handleTapDown,
       onTapUp: _handleTapUp,
       onTapCancel: _handleTapCancel,
       onTap: () {/* onTap handled by Up/Down/Cancel */}, // Keep onTap empty or remove
       child: ScaleTransition( // Apply scale animation
         scale: _scaleAnimation,
         child: Card(
           elevation: _cardElevation,
           shape: RoundedRectangleBorder(
             borderRadius: BorderRadius.circular(_cardCornerRadius),
           ),
           color: isActive ? _buzzerButtonColor.withOpacity(0.8) : _buzzerButtonColor, // Slightly dim when active?
           child: Padding(
             padding: const EdgeInsets.symmetric(vertical: 20.0, horizontal: 16.0), // Adjust padding
             child: Row(
               mainAxisAlignment: MainAxisAlignment.center,
               children: [
                 // Use a pulsing icon effect when active
                 isActive
                   ? FadeTransition(
                       opacity: _animationController,
                       child: const Icon(Icons.notifications_active, color: Colors.white, size: 32.0),
                     )
                   : const Icon(Icons.notifications_off_outlined, color: Colors.white70, size: 32.0), // Different icon when off
                 const SizedBox(width: 12),
                 Text(
                   isActive ? 'Buzzer Active' : 'Activate Buzzer',
                   style: const TextStyle(
                     fontSize: 18,
                     fontWeight: FontWeight.w500,
                     color: Colors.white,
                   ),
                 ),
               ],
             ),
           ),
         ),
       ),
    );
  }
}


// --- Main Dashboard Screen Widget ---
class InhalerDashboardScreen1 extends StatefulWidget {
  const InhalerDashboardScreen1({Key? key}) : super(key: key);

  @override
  _InhalerDashboardScreen1State createState() => _InhalerDashboardScreen1State();
}

class _InhalerDashboardScreen1State extends State<InhalerDashboardScreen1> {
  late DatabaseReference _dbRef;
  StreamSubscription<DatabaseEvent>? _subscription;
  bool _isConnected = false;
  bool _isInitializing = true; // Track initial connection attempt

  // Variables for dose tracking
  int _doseCount = 90; // Default value
  int _maxDoseCount = 100; // Default value

  // Variables to store MPU6050 data
  double _accelX = 0.0;
  double _accelY = 0.0;
  double _accelZ = 0.0;
  double _gyroX = 0.0;
  double _gyroY = 0.0;
  double _gyroZ = 0.0;
  double _temp = 0.0;

  // Variables for FSR data
  int _fsrSensor1 = 0;
  int _fsrSensor2 = 0;
  int _fsrSensor3 = 0;

  // Buzzer control value
  int _buzzerControl = 0;

  bool _doseCounted = false; // Flag to prevent multiple counts
  Timer? _doseCountResetTimer; // Timer to reset the flag
  Timer? _buzzerResetTimer; // Timer for auto-resetting buzzer

  @override
  void initState() {
    super.initState();
    _initializeDatabase();
  }

  Future<void> _initializeDatabase() async {
    setState(() {
       _isInitializing = true; // Start initialization indicator
    });
    try {
      FirebaseDatabase database = FirebaseDatabase.instance;
      // Ensure your databaseURL is correct
      database.databaseURL =
          'https://smart-inhaler-db-default-rtdb.asia-southeast1.firebasedatabase.app/';

      _dbRef = database.ref();
      print('Database reference created: ${_dbRef.path}');

      // Attempt to get initial values once
      try {
         final snapshot = await _dbRef.get();
         if (snapshot.exists && snapshot.value != null) {
            print('Initial data fetched successfully.');
            _parseData(snapshot.value); // Parse initial data
             setState(() {
               _isConnected = true; // Assume connected if initial fetch works
             });
         } else {
            print('Initial data fetch: No data found at root.');
             // Keep default values if no initial data
         }
      } catch(e) {
          print('Error fetching initial data: $e');
          // Keep defaults, show error later if subscription also fails
      }


      // Listen for subsequent value changes
      _subscription = _dbRef.onValue.listen(
        (DatabaseEvent event) {
          // print('Data received: ${event.snapshot.value}'); // Can be noisy, uncomment if needed
          if (event.snapshot.value != null) {
            _parseData(event.snapshot.value);
            if (!_isConnected) {
               setState(() {
                 _isConnected = true; // Mark as connected once data flows
               });
            }
          } else {
            print('No data received from Firebase stream');
            // Don't necessarily mark as disconnected here, could be temporary
            // Maybe add a timeout check later if needed
          }
        },
        onError: (error) {
          print('Database stream error: $error');
          if (mounted) { // Check if widget is still in the tree
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Firebase connection error: ${error.toString()}')),
            );
            setState(() {
              _isConnected = false;
            });
          }
        },
        onDone: () {
          print('Database connection closed');
           if (mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(content: Text('Firebase connection closed')),
             );
             setState(() {
               _isConnected = false;
             });
           }
        },
      );
       // Mark initialization complete after setting up listener
       setState(() {
         _isInitializing = false;
       });

    } catch (e) {
      print('Error setting up database reference: $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('Error setting up Firebase: ${e.toString()}')),
         );
         setState(() {
           _isConnected = false;
           _isInitializing = false; // Initialization failed
         });
       }
    }
  }

  // Centralized data parsing logic
  void _parseData(dynamic rawData) {
     if (rawData == null) return;

     try {
        final data = Map<String, dynamic>.from(rawData as Map);

        // --- FSR and Dose Counting Logic ---
        if (data.containsKey('FSR') && data['FSR'] is Map) {
          final fsrData = Map<String, dynamic>.from(data['FSR']);
          final oldFSR1 = _fsrSensor1;
          final oldFSR2 = _fsrSensor2;
          final oldFSR3 = _fsrSensor3;

          // Update FSR values safely
          final newFSR1 = _parseIntValue(fsrData['sensor1']);
          final newFSR2 = _parseIntValue(fsrData['sensor2']);
          final newFSR3 = _parseIntValue(fsrData['sensor3']);


          // Check for dose decrement condition
          bool allNonZeroNow = newFSR1 > 50 && newFSR2 > 50 && newFSR3 > 50; // Added threshold
          bool anyZeroBefore = oldFSR1 <= 50 || oldFSR2 <= 50 || oldFSR3 <= 50; // Use threshold

          if (allNonZeroNow && anyZeroBefore && _doseCount > 0 && !_doseCounted) {
             print("Dose condition met! Decrementing count.");
            _doseCounted = true; // Set flag immediately
             final newDoseCount = _doseCount - 1;

             // Update Firebase first
             _dbRef.update({'doseCount': newDoseCount}).then((_) {
                print("Firebase doseCount updated to $newDoseCount");
                // Update local state only after successful Firebase update
                if (mounted) {
                  setState(() {
                    _doseCount = newDoseCount;
                  });
                }
             }).catchError((error) {
                print("Error updating Firebase doseCount: $error");
                 _doseCounted = false; // Reset flag on error
             });


            // Reset the flag after a delay to prevent rapid counts
            _doseCountResetTimer?.cancel(); // Cancel previous timer if any
            _doseCountResetTimer = Timer(const Duration(seconds: 2), () {
                print("Resetting dose count flag.");
              _doseCounted = false;
            });
          }
           // Update state for FSR values *after* checking dose condition
           if(mounted) {
             setState(() {
                 _fsrSensor1 = newFSR1;
                 _fsrSensor2 = newFSR2;
                 _fsrSensor3 = newFSR3;
             });
           }
        }

        // --- Dose Count Update (from Firebase) ---
        if (data.containsKey('doseCount')) {
           final firebaseDoseCount = _parseIntValue(data['doseCount']);
           // Only update if different from local to avoid unnecessary rebuilds
           if (firebaseDoseCount != _doseCount && mounted) {
              setState(() {
                _doseCount = firebaseDoseCount;
              });
           }
        }

        // --- Max Dose Count Update (from Firebase, optional) ---
         if (data.containsKey('maxDoseCount')) {
           final firebaseMaxDoseCount = _parseIntValue(data['maxDoseCount']);
           if (firebaseMaxDoseCount != _maxDoseCount && firebaseMaxDoseCount > 0 && mounted) {
              setState(() {
                _maxDoseCount = firebaseMaxDoseCount;
              });
           }
        }


        // --- Buzzer Control Update (from Firebase) ---
        if (data.containsKey('buzzerControl')) {
           final firebaseBuzzerControl = _parseIntValue(data['buzzerControl']);
            if (firebaseBuzzerControl != _buzzerControl && mounted) {
               setState(() {
                 _buzzerControl = firebaseBuzzerControl;
               });
            }
        }

        // --- MPU Data Update ---
        if (data.containsKey('MPU') && data['MPU'] is Map) {
          final mpuData = Map<String, dynamic>.from(data['MPU']);


          // Extract accelerometer data
          if (mpuData.containsKey('accelerometer') && mpuData['accelerometer'] is Map) {
            final accelData = Map<String, dynamic>.from(mpuData['accelerometer']);
            _accelX = _parseDoubleValue(accelData['x']);
            _accelY = _parseDoubleValue(accelData['y']);
            _accelZ = _parseDoubleValue(accelData['z']);
          }

          // Extract gyroscope data
          if (mpuData.containsKey('gyroscope') && mpuData['gyroscope'] is Map) {
            final gyroData = Map<String, dynamic>.from(mpuData['gyroscope']);
             _gyroX = _parseDoubleValue(gyroData['x']);
             _gyroY = _parseDoubleValue(gyroData['y']);
             _gyroZ = _parseDoubleValue(gyroData['z']);
          }

          // Extract temperature
          if (mpuData.containsKey('temp')) {
             _temp = _parseDoubleValue(mpuData['temp']);
          }

          if (mounted) {
             setState(() {
                // Triggers UI update
             });
          }

        }

        // Final connection status update (redundant if already connected, but safe)
         if (!_isConnected && mounted) {
             setState(() {
                _isConnected = true;
             });
         }

     } catch (e) {
         print('Error parsing data: $e');
         print('Problematic data chunk: $rawData'); // Log the raw data that caused the error
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error processing incoming data: ${e.toString()}')),
            );
          }
          // Consider if you want to set _isConnected to false here
     }
  }


  // Helper method to parse int values safely
  int _parseIntValue(dynamic value) {
    if (value == null) return 0;
    if (value is int) {
      return value;
    } else if (value is double) {
      return value.toInt();
    } else {
      return int.tryParse(value.toString()) ?? 0;
    }
  }

   // Helper method to parse double values safely
  double _parseDoubleValue(dynamic value) {
    if (value == null) return 0.0;
    if (value is double) {
      return value;
    } else if (value is int) {
      return value.toDouble();
    } else {
      return double.tryParse(value.toString()) ?? 0.0;
    }
  }


  // Function to update buzzer control value in Firebase
  Future<void> _updateBuzzerControl() async {
     if (!_isConnected) {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Not connected to inhaler.')));
        return;
     }

     final nextBuzzerState = _buzzerControl == 0 ? 29 : 0; // Determine next state

     try {
        print('Attempting to set buzzerControl to $nextBuzzerState');
        await _dbRef.update({'buzzerControl': nextBuzzerState});
        print('Buzzer control update sent successfully.');

        // Update local state optimistically *after* successful send
        if (mounted) {
           setState(() {
             _buzzerControl = nextBuzzerState;
           });
        }


        // Cancel any existing auto-reset timer
        _buzzerResetTimer?.cancel();

        // If activating, start auto-reset timer
        if (nextBuzzerState == 29) {
           _buzzerResetTimer = Timer(const Duration(seconds: 5), () async {
             // Check if buzzer is *still* active before resetting
             if (_buzzerControl == 29) {
                 print('Auto-resetting buzzer control to 0');
                 try {
                    await _dbRef.update({'buzzerControl': 0});
                    if (mounted) {
                       setState(() { _buzzerControl = 0;});
                    }
                 } catch (e) {
                     print('Error auto-resetting buzzer control: $e');
                     // Handle error - maybe show a snackbar
                 }
             } else {
                 print('Buzzer was manually turned off before auto-reset.');
             }
           });
        }
     } catch (e) {
        print('Error updating buzzer control: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error updating buzzer: ${e.toString()}')),
          );
        }
     }
  }

  // Function to edit dose count
  void _editDoseCount() {
     if (!_isConnected && !_isInitializing) { // Allow edit even if initializing maybe? Or check !isInitializing
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Cannot edit dose count while disconnected.')));
        return;
     }

    final newDoseCountController = TextEditingController(text: _doseCount.toString());
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Edit Dose Count'),
          content: TextField(
            controller: newDoseCountController,
            keyboardType: TextInputType.number,
            autofocus: true, // Focus the field immediately
            decoration: InputDecoration(
              labelText: 'Enter remaining doses',
              hintText: _doseCount.toString(),
              suffixText: '/ $_maxDoseCount', // Show max doses
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                final newDoseCountInt = int.tryParse(newDoseCountController.text);
                if (newDoseCountInt == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter a valid number.')),
                  );
                  return; // Keep dialog open
                }
                if (newDoseCountInt < 0 || newDoseCountInt > _maxDoseCount) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Dose count must be between 0 and $_maxDoseCount.')),
                  );
                  return; // Keep dialog open
                }

                // Update Firebase first
                _dbRef.update({'doseCount': newDoseCountInt}).then((_) {
                   print("Manual dose count update to $newDoseCountInt successful.");
                   // Update local state on success
                   if (mounted) {
                     setState(() {
                       _doseCount = newDoseCountInt;
                     });
                   }
                   Navigator.of(context).pop(); // Close dialog on success
                }).catchError((error) {
                    print("Error manually updating dose count: $error");
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Failed to save dose count: $error')),
                    );
                     // Don't close dialog on error
                });
              },
              child: const Text('Save'),
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    print("Disposing InhalerDashboardScreen1");
    _subscription?.cancel();
    _doseCountResetTimer?.cancel();
    _buzzerResetTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget bodyContent;

     if (_isInitializing) {
       bodyContent = const Center(
         child: Column(
           mainAxisAlignment: MainAxisAlignment.center,
           children: [
             CircularProgressIndicator(),
             SizedBox(height: 16),
             Text('Initializing connection...'),
           ],
         ),
       );
     } else if (!_isConnected) {
        bodyContent = Center(
           child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                 mainAxisAlignment: MainAxisAlignment.center,
                 children: [
                    Icon(Icons.cloud_off, size: 60, color: Colors.red[300]),
                    const SizedBox(height: 16),
                    const Text(
                      'Disconnected from Inhaler',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),
                     const Text(
                       'Please check the device connection and your internet.',
                       textAlign: TextAlign.center,
                       style: TextStyle(color: Colors.grey),
                    ),
                    const SizedBox(height: 20),
                    ElevatedButton.icon( // Add a retry button maybe?
                       icon: const Icon(Icons.refresh),
                       label: const Text('Retry Connection'),
                       onPressed: _initializeDatabase, // Re-run initialization
                    )
                 ],
              ),
           ),
        );
     } else {
       // --- Connected State ---
       bodyContent = SingleChildScrollView(
         child: Padding(
           padding: const EdgeInsets.all(16.0),
           child: Column(
             mainAxisAlignment: MainAxisAlignment.start,
             children: [
               DoseCounter(
                 doseCount: _doseCount,
                 maxDoseCount: _maxDoseCount,
                 onEdit: _editDoseCount,
               ),
               const SizedBox(height: 24), // More space after counter
               MotionSensorNumericalData(
                 accelX: _accelX,
                 accelY: _accelY,
                 accelZ: _accelZ,
                 gyroX: _gyroX,
                 gyroY: _gyroY,
                 gyroZ: _gyroZ,
                 temp: _temp,
               ),
               const SizedBox(height: 24),
               BuzzerControl(
                 buzzerControl: _buzzerControl,
                 onToggle: _updateBuzzerControl,
               ),
               const SizedBox(height: 30), // Space before the new button
               // --- Navigation Button ---
               ElevatedButton(
                 onPressed: () {
                   Navigator.push(
                     context,
                     MaterialPageRoute(builder: (context) => const FirebaseDataScreen2()),
                   );
                 },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 50), // Make button wider
                    // backgroundColor: Colors.deepPurpleAccent, // Example styling
                     shape: RoundedRectangleBorder(
                       borderRadius: BorderRadius.circular(12),
                     )
                  ),
                 child: const Text('Go to Screen 2'),
               ),
               const SizedBox(height: 20), // Some padding at the bottom
               ElevatedButton( // Add graph screen navigation
                 onPressed: () {
                   Navigator.push(
                     context,
                     MaterialPageRoute(builder: (context) => const GraphScreen()),
                   );
                 },
                 style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 50), // Make button wider
                    // backgroundColor: Colors.deepPurpleAccent, // Example styling
                     shape: RoundedRectangleBorder(
                       borderRadius: BorderRadius.circular(12),
                     )
                  ),
                 child: const Text('View Graphs'),
               ),
               const SizedBox(height: 20),
             ],
           ),
         ),
       );
     }

    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background
      appBar: AppBar(
        title: const Text('Smart Inhaler Dashboard'), // More descriptive title
        elevation: 1, // Subtle shadow
        backgroundColor: Colors.white, // White appbar
        foregroundColor: _textColor, // Dark text on white appbar
        actions: [
          // Connection status indicator
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: Center( // Center the indicator vertically
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                   color: _isConnected ? Colors.green[100] : Colors.red[100],
                   borderRadius: BorderRadius.circular(10),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                       _isConnected ? Icons.wifi : Icons.wifi_off,
                       color: _isConnected ? Colors.green[800] : Colors.red[800],
                       size: 16,
                     ),
                     const SizedBox(width: 4),
                      Text(
                       _isConnected ? 'Connected' : 'Offline',
                       style: TextStyle(
                          color: _isConnected ? Colors.green[800] : Colors.red[800],
                          fontSize: 12,
                          fontWeight: FontWeight.bold
                       ),
                     ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
      body: SafeArea( // Added SafeArea
        child: bodyContent, // Display the appropriate content
      ),
    );
  }
}

//2screen1

import 'package:flutter/material.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:smart_inhaler/graphscreen.dart';
import 'dart:async';
import 'test.dart'; // Import screen 2
import 'graphscreen.dart'; // Import graph screen
import 'buzzer_control.dart'; // Import BuzzerControl

// --- Constants (Moved here as they are specific to this screen's UI) ---
const Color _motionSensorCardColor = Color(0xFFB2EBF2); // Light Teal
const Color _buzzerButtonColor = Color(0xFFFFAB91); // Warm Coral
const Color _textColor = Color(0xFF212121);
const double _cardCornerRadius = 12.0;
const double _cardElevation = 4.0;

// --- Dose Counter Widget ---
class DoseCounter extends StatefulWidget {
  final int doseCount;
  final int maxDoseCount;
  final VoidCallback onEdit;

  const DoseCounter({
    Key? key,
    required this.doseCount,
    required this.maxDoseCount,
    required this.onEdit,
  }) : super(key: key);

  @override
  _DoseCounterState createState() => _DoseCounterState();
}

class _DoseCounterState extends State<DoseCounter>
    with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _animation = Tween<double>(begin: 1.0, end: 1.2).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
  }

  @override
  void didUpdateWidget(covariant DoseCounter oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.doseCount < oldWidget.doseCount) {
      _animationController.reset();
      _animationController.forward();
    }
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  Color _getProgressColor(double progress) {
    if (progress > 0.6) {
      return Colors.cyan; // Plenty of doses left
    } else if (progress > 0.3) {
      return Colors.orange; // Getting low
    } else {
      return Colors.red; // Very low, needs replacement
    }
  }

  @override
  Widget build(BuildContext context) {
    double progress = widget.doseCount / widget.maxDoseCount;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          const Text(
            'Doses Remaining', // Added title here
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.w500,
              color: _textColor,
            ),
          ),
          const SizedBox(height: 12),
          GestureDetector(
            onTap: widget.onEdit,
            child: Stack(
              alignment: Alignment.center,
              children: [
                // Outer progress circle
                SizedBox(
                  width: 230,
                  height: 230,
                  child: CircularProgressIndicator(
                    value: progress,
                    strokeWidth: 25,
                    backgroundColor: Colors.grey.withOpacity(0.2),
                    valueColor: AlwaysStoppedAnimation<Color>(_getProgressColor(progress)), // Use valueColor
                  ),
                ),
                // Inner circle with radial gradient and white numbers
                ScaleTransition(
                  scale: _animation,
                  child: Container(
                    width: 205,
                    height: 205,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      gradient: RadialGradient(
                        colors: [
                          Colors.blue,
                          Color(0xFF00008B), // Dark Blue
                        ],
                        center: Alignment.center,
                        radius: 0.7,
                      ),
                    ),
                    child: Center(
                      child: Text(
                        '${widget.doseCount}',
                        style: const TextStyle(
                          fontSize: 60,
                          fontWeight: FontWeight.bold,
                          color: Colors.white, // White text color
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8), // Add some space below the counter
           Text(
            'Tap to edit', // Hint for editing
            style: TextStyle(color: Colors.grey[600]),
          ),
        ],
      ),
    );
  }
}

// --- Motion Sensor Data Widget (Numerical Values Only) ---
class MotionSensorNumericalData extends StatelessWidget {
  final double accelX;
  final double accelY;
  final double accelZ;
  final double gyroX;
  final double gyroY;
  final double gyroZ;
  final double temp;

  const MotionSensorNumericalData({
    Key? key,
    required this.accelX,
    required this.accelY,
    required this.accelZ,
    required this.gyroX,
    required this.gyroY,
    required this.gyroZ,
    required this.temp,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: _cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(_cardCornerRadius),
      ),
      color: _motionSensorCardColor,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Motion Sensor Data (Numerical)',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.w500,
                color: _textColor,
              ),
            ),
            const SizedBox(height: 12),
            _buildDataRow('Acceleration X:', accelX.toStringAsFixed(3)),
            _buildDataRow('Acceleration Y:', accelY.toStringAsFixed(3)),
            _buildDataRow('Acceleration Z:', accelZ.toStringAsFixed(3)),
            _buildDataRow('Gyroscope X:', gyroX.toStringAsFixed(3)),
            _buildDataRow('Gyroscope Y:', gyroY.toStringAsFixed(3)),
            _buildDataRow('Gyroscope Z:', gyroZ.toStringAsFixed(3)),
            const SizedBox(height: 12),
            _buildDataRow('Temperature:', '${temp.toStringAsFixed(1)}Â°C'),
          ],
        ),
      ),
    );
  }

  Widget _buildDataRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: _textColor,
            ),
          ),
          Text(
            value,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: _textColor,
            ),
          ),
        ],
      ),
    );
  }
}


// --- Main Dashboard Screen Widget ---
class InhalerDashboardScreen1 extends StatefulWidget {
  const InhalerDashboardScreen1({Key? key}) : super(key: key);

  @override
  _InhalerDashboardScreen1State createState() => _InhalerDashboardScreen1State();
}

class _InhalerDashboardScreen1State extends State<InhalerDashboardScreen1> {
  late DatabaseReference _dbRef;
  StreamSubscription<DatabaseEvent>? _subscription;
  bool _isConnected = false;
  bool _isInitializing = true; // Track initial connection attempt

  // Variables for dose tracking
  int _doseCount = 90; // Default value
  int _maxDoseCount = 100; // Default value

  // Variables to store MPU6050 data
  double _accelX = 0.0;
  double _accelY = 0.0;
  double _accelZ = 0.0;
  double _gyroX = 0.0;
  double _gyroY = 0.0;
  double _gyroZ = 0.0;
  double _temp = 0.0;

  // Variables for FSR data
  int _fsrSensor1 = 0;
  int _fsrSensor2 = 0;
  int _fsrSensor3 = 0;

  // Buzzer control value
  int _buzzerControl = 0;

  bool _doseCounted = false; // Flag to prevent multiple counts
  Timer? _doseCountResetTimer; // Timer to reset the flag
  Timer? _buzzerResetTimer; // Timer for auto-resetting buzzer

  @override
  void initState() {
    super.initState();
    _initializeDatabase();
  }

  Future<void> _initializeDatabase() async {
    setState(() {
       _isInitializing = true; // Start initialization indicator
    });
    try {
      FirebaseDatabase database = FirebaseDatabase.instance;
      // Ensure your databaseURL is correct
      database.databaseURL =
          'https://smart-inhaler-db-default-rtdb.asia-southeast1.firebasedatabase.app/';

      _dbRef = database.ref();
      print('Database reference created: ${_dbRef.path}');

      // Attempt to get initial values once
      try {
         final snapshot = await _dbRef.get();
         if (snapshot.exists && snapshot.value != null) {
            print('Initial data fetched successfully.');
            _parseData(snapshot.value); // Parse initial data
             setState(() {
               _isConnected = true; // Assume connected if initial fetch works
             });
         } else {
            print('Initial data fetch: No data found at root.');
             // Keep default values if no initial data
         }
      } catch(e) {
          print('Error fetching initial data: $e');
          // Keep defaults, show error later if subscription also fails
      }


      // Listen for subsequent value changes
      _subscription = _dbRef.onValue.listen(
        (DatabaseEvent event) {
          // print('Data received: ${event.snapshot.value}'); // Can be noisy, uncomment if needed
          if (event.snapshot.value != null) {
            _parseData(event.snapshot.value);
            if (!_isConnected) {
               setState(() {
                 _isConnected = true; // Mark as connected once data flows
               });
            }
          } else {
            print('No data received from Firebase stream');
            // Don't necessarily mark as disconnected here, could be temporary
            // Maybe add a timeout check later if needed
          }
        },
        onError: (error) {
          print('Database stream error: $error');
          if (mounted) { // Check if widget is still in the tree
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Firebase connection error: ${error.toString()}')),
            );
            setState(() {
              _isConnected = false;
            });
          }
        },
        onDone: () {
          print('Database connection closed');
           if (mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(content: Text('Firebase connection closed')),
             );
             setState(() {
               _isConnected = false;
             });
           }
        },
      );
       // Mark initialization complete after setting up listener
       setState(() {
         _isInitializing = false;
       });

    } catch (e) {
      print('Error setting up database reference: $e');
       if (mounted) {
         ScaffoldMessenger.of(context).showSnackBar(
           SnackBar(content: Text('Error setting up Firebase: ${e.toString()}')),
         );
         setState(() {
           _isConnected = false;
           _isInitializing = false; // Initialization failed
         });
       }
    }
  }

  // Centralized data parsing logic
  void _parseData(dynamic rawData) {
     if (rawData == null) return;

     try {
        final data = Map<String, dynamic>.from(rawData as Map);

        // --- FSR and Dose Counting Logic ---
        if (data.containsKey('FSR') && data['FSR'] is Map) {
          final fsrData = Map<String, dynamic>.from(data['FSR']);
          final oldFSR1 = _fsrSensor1;
          final oldFSR2 = _fsrSensor2;
          final oldFSR3 = _fsrSensor3;

          // Update FSR values safely
          final newFSR1 = _parseIntValue(fsrData['sensor1']);
          final newFSR2 = _parseIntValue(fsrData['sensor2']);
          final newFSR3 = _parseIntValue(fsrData['sensor3']);


          // Check for dose decrement condition
          bool allNonZeroNow = newFSR1 > 50 && newFSR2 > 50 && newFSR3 > 50; // Added threshold
          bool anyZeroBefore = oldFSR1 <= 50 || oldFSR2 <= 50 || oldFSR3 <= 50; // Use threshold

          if (allNonZeroNow && anyZeroBefore && _doseCount > 0 && !_doseCounted) {
             print("Dose condition met! Decrementing count.");
            _doseCounted = true; // Set flag immediately
             final newDoseCount = _doseCount - 1;

             // Update Firebase first
             _dbRef.update({'doseCount': newDoseCount}).then((_) {
                print("Firebase doseCount updated to $newDoseCount");
                // Update local state only after successful Firebase update
                if (mounted) {
                  setState(() {
                    _doseCount = newDoseCount;
                  });
                }
             }).catchError((error) {
                print("Error updating Firebase doseCount: $error");
                 _doseCounted = false; // Reset flag on error
             });


            // Reset the flag after a delay to prevent rapid counts
            _doseCountResetTimer?.cancel(); // Cancel previous timer if any
            _doseCountResetTimer = Timer(const Duration(seconds: 2), () {
                print("Resetting dose count flag.");
              _doseCounted = false;
            });
          }
           // Update state for FSR values *after* checking dose condition
           if(mounted) {
             setState(() {
                 _fsrSensor1 = newFSR1;
                 _fsrSensor2 = newFSR2;
                 _fsrSensor3 = newFSR3;
             });
           }
        }

        // --- Dose Count Update (from Firebase) ---
        if (data.containsKey('doseCount')) {
           final firebaseDoseCount = _parseIntValue(data['doseCount']);
           // Only update if different from local to avoid unnecessary rebuilds
           if (firebaseDoseCount != _doseCount && mounted) {
              setState(() {
                _doseCount = firebaseDoseCount;
              });
           }
        }

        // --- Max Dose Count Update (from Firebase, optional) ---
         if (data.containsKey('maxDoseCount')) {
           final firebaseMaxDoseCount = _parseIntValue(data['maxDoseCount']);
           if (firebaseMaxDoseCount != _maxDoseCount && firebaseMaxDoseCount > 0 && mounted) {
              setState(() {
                _maxDoseCount = firebaseMaxDoseCount;
              });
           }
        }


        // --- Buzzer Control Update (from Firebase) ---
        if (data.containsKey('buzzerControl')) {
           final firebaseBuzzerControl = _parseIntValue(data['buzzerControl']);
            if (firebaseBuzzerControl != _buzzerControl && mounted) {
               setState(() {
                 _buzzerControl = firebaseBuzzerControl;
               });
            }
        }

        // --- MPU Data Update ---
        if (data.containsKey('MPU') && data['MPU'] is Map) {
          final mpuData = Map<String, dynamic>.from(data['MPU']);


          // Extract accelerometer data
          if (mpuData.containsKey('accelerometer') && mpuData['accelerometer'] is Map) {
            final accelData = Map<String, dynamic>.from(mpuData['accelerometer']);
            _accelX = _parseDoubleValue(accelData['x']);
            _accelY = _parseDoubleValue(accelData['y']);
            _accelZ = _parseDoubleValue(accelData['z']);
          }

          // Extract gyroscope data
          if (mpuData.containsKey('gyroscope') && mpuData['gyroscope'] is Map) {
            final gyroData = Map<String, dynamic>.from(mpuData['gyroscope']);
             _gyroX = _parseDoubleValue(gyroData['x']);
             _gyroY = _parseDoubleValue(gyroData['y']);
             _gyroZ = _parseDoubleValue(gyroData['z']);
          }

          // Extract temperature
          if (mpuData.containsKey('temp')) {
             _temp = _parseDoubleValue(mpuData['temp']);
          }

          if (mounted) {
             setState(() {
                // Triggers UI update
             });
          }

        }

        // Final connection status update (redundant if already connected, but safe)
         if (!_isConnected && mounted) {
             setState(() {
                _isConnected = true;
             });
         }

     } catch (e) {
         print('Error parsing data: $e');
         print('Problematic data chunk: $rawData'); // Log the raw data that caused the error
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('Error processing incoming data: ${e.toString()}')),
            );
          }
          // Consider if you want to set _isConnected to false here
     }
  }


  // Helper method to parse int values safely
  int _parseIntValue(dynamic value) {
    if (value == null) return 0;
    if (value is int) {
      return value;
    } else if (value is double) {
      return value.toInt();
    } else {
      return int.tryParse(value.toString()) ?? 0;
    }
  }

   // Helper method to parse double values safely
  double _parseDoubleValue(dynamic value) {
    if (value == null) return 0.0;
    if (value is double) {
      return value;
    } else if (value is int) {
      return value.toDouble();
    } else {
      return double.tryParse(value.toString()) ?? 0.0;
    }
  }


  // Function to update buzzer control value in Firebase
  Future<void> _updateBuzzerControl() async {
     if (!_isConnected) {
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Not connected to inhaler.')));
        return;
     }

     final nextBuzzerState = _buzzerControl == 0 ? 29 : 0; // Determine next state

     try {
        print('Attempting to set buzzerControl to $nextBuzzerState');
        await _dbRef.update({'buzzerControl': nextBuzzerState});
        print('Buzzer control update sent successfully.');

        // Update local state optimistically *after* successful send
        if (mounted) {
           setState(() {
             _buzzerControl = nextBuzzerState;
           });
        }


        // Cancel any existing auto-reset timer
        _buzzerResetTimer?.cancel();

        // If activating, start auto-reset timer
        if (nextBuzzerState == 29) {
           _buzzerResetTimer = Timer(const Duration(seconds: 5), () async {
             // Check if buzzer is *still* active before resetting
             if (_buzzerControl == 29) {
                 print('Auto-resetting buzzer control to 0');
                 try {
                    await _dbRef.update({'buzzerControl': 0});
                    if (mounted) {
                       setState(() { _buzzerControl = 0;});
                    }
                 } catch (e) {
                     print('Error auto-resetting buzzer control: $e');
                     // Handle error - maybe show a snackbar
                 }
             } else {
                 print('Buzzer was manually turned off before auto-reset.');
             }
           });
        }
     } catch (e) {
        print('Error updating buzzer control: $e');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error updating buzzer: ${e.toString()}')),
          );
        }
     }
  }

  // Function to edit dose count
  void _editDoseCount() {
     if (!_isConnected && !_isInitializing) { // Allow edit even if initializing maybe? Or check !isInitializing
        ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Cannot edit dose count while disconnected.')));
        return;
     }

    final newDoseCountController = TextEditingController(text: _doseCount.toString());
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Edit Dose Count'),
          content: TextField(
            controller: newDoseCountController,
            keyboardType: TextInputType.number,
            autofocus: true, // Focus the field immediately
            decoration: InputDecoration(
              labelText: 'Enter remaining doses',
              hintText: _doseCount.toString(),
              suffixText: '/ $_maxDoseCount', // Show max doses
            ),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                final newDoseCountInt = int.tryParse(newDoseCountController.text);
                if (newDoseCountInt == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Please enter a valid number.')),
                  );
                  return; // Keep dialog open
                }
                if (newDoseCountInt < 0 || newDoseCountInt > _maxDoseCount) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Dose count must be between 0 and $_maxDoseCount.')),
                  );
                  return; // Keep dialog open
                }

                // Update Firebase first
                _dbRef.update({'doseCount': newDoseCountInt}).then((_) {
                   print("Manual dose count update to $newDoseCountInt successful.");
                   // Update local state on success
                   if (mounted) {
                     setState(() {
                       _doseCount = newDoseCountInt;
                     });
                   }
                   Navigator.of(context).pop(); // Close dialog on success
                }).catchError((error) {
                    print("Error manually updating dose count: $error");
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text('Failed to save dose count: $error')),
                    );
                     // Don't close dialog on error
                });
              },
              child: const Text('Save'),
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    print("Disposing InhalerDashboardScreen1");
    _subscription?.cancel();
    _doseCountResetTimer?.cancel();
    _buzzerResetTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Widget bodyContent;

     if (_isInitializing) {
       bodyContent = const Center(
         child: Column(
           mainAxisAlignment: MainAxisAlignment.center,
           children: [
             CircularProgressIndicator(),
             SizedBox(height: 16),
             Text('Initializing connection...'),
           ],
         ),
       );
     } else if (!_isConnected) {
        bodyContent = Center(
           child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                 mainAxisAlignment: MainAxisAlignment.center,
                 children: [
                    Icon(Icons.cloud_off, size: 60, color: Colors.red[300]),
                    const SizedBox(height: 16),
                    const Text(
                      'Disconnected from Inhaler',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),
                     const Text(
                       'Please check the device connection and your internet.',
                       textAlign: TextAlign.center,
                       style: TextStyle(color: Colors.grey),
                    ),
                    const SizedBox(height: 20),
                    ElevatedButton.icon( // Add a retry button maybe?
                       icon: const Icon(Icons.refresh),
                       label: const Text('Retry Connection'),
                       onPressed: _initializeDatabase, // Re-run initialization
                    )
                 ],
              ),
           ),
        );
     } else {
       // --- Connected State ---
       bodyContent = SingleChildScrollView(
         child: Padding(
           padding: const EdgeInsets.all(16.0),
           child: Column(
             mainAxisAlignment: MainAxisAlignment.start,
             children: [
               DoseCounter(
                 doseCount: _doseCount,
                 maxDoseCount: _maxDoseCount,
                 onEdit: _editDoseCount,
               ),
               const SizedBox(height: 24), // More space after counter
               MotionSensorNumericalData(
                 accelX: _accelX,
                 accelY: _accelY,
                 accelZ: _accelZ,
                 gyroX: _gyroX,
                 gyroY: _gyroY,
                 gyroZ: _gyroZ,
                 temp: _temp,
               ),
               const SizedBox(height: 24),
               BuzzerControl(
                 buzzerControl: _buzzerControl,
                 onToggle: _updateBuzzerControl,
               ),
               const SizedBox(height: 30), // Space before the new button
               // --- Navigation Button ---
               ElevatedButton(
                 onPressed: () {
                   Navigator.push(
                     context,
                     MaterialPageRoute(builder: (context) => const FirebaseDataScreen2()),
                   );
                 },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 50), // Make button wider
                    // backgroundColor: Colors.deepPurpleAccent, // Example styling
                     shape: RoundedRectangleBorder(
                       borderRadius: BorderRadius.circular(12),
                     )
                  ),
                 child: const Text('Go to Screen 2'),
               ),
               const SizedBox(height: 20), // Some padding at the bottom
               ElevatedButton( // Add graph screen navigation
                 onPressed: () {
                   Navigator.push(
                     context,
                     MaterialPageRoute(builder: (context) => const GraphScreen()),
                   );
                 },
                 style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 50), // Make button wider
                    // backgroundColor: Colors.deepPurpleAccent, // Example styling
                     shape: RoundedRectangleBorder(
                       borderRadius: BorderRadius.circular(12),
                     )
                  ),
                 child: const Text('View Graphs'),
               ),
               const SizedBox(height: 20),
             ],
           ),
         ),
       );
     }

    return Scaffold(
      backgroundColor: Colors.grey[100], // Light background
      appBar: AppBar(
        title: const Text('Smart Inhaler Dashboard'), // More descriptive title
        elevation: 1, // Subtle shadow
        backgroundColor: Colors.white, // White appbar
        foregroundColor: _textColor, // Dark text on white appbar
        actions: [
          // Connection status indicator
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: Center( // Center the indicator vertically
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                   color: _isConnected ? Colors.green[100] : Colors.red[100],
                   borderRadius: BorderRadius.circular(10),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                       _isConnected ? Icons.wifi : Icons.wifi_off,
                       color: _isConnected ? Colors.green[800] : Colors.red[800],
                       size: 16,
                     ),
                     const SizedBox(width: 4),
                      Text(
                       _isConnected ? 'Connected' : 'Offline',
                       style: TextStyle(
                          color: _isConnected ? Colors.green[800] : Colors.red[800],
                          fontSize: 12,
                          fontWeight: FontWeight.bold
                       ),
                     ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
      body: SafeArea( // Added SafeArea
        child: bodyContent, // Display the appropriate content
      ),
    );
  }
}

//widget  MotionSensorNumericalData(
                accelX: _accelX, accelY: _accelY, accelZ: _accelZ,
                gyroX: _gyroX, gyroY: _gyroY, gyroZ: _gyroZ,
                temp: _temp,
              ),